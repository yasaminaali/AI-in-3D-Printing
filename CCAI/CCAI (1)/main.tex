%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Canadian AI Latex Template    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[10pt]{cai}

\begin{document}
% Editorial staff will replace the following values:
% 1. Conference Year
% 2. Issue number
% 3. Article DOI
\def\conferenceyear{2026}
\volumeheader{37}{0}%{00.000}
\begin{center}

\title{Sequence-Based Evolutionary and Neural Strategies for Reducing Zone Crossings in Toolpaths}
\maketitle

\thispagestyle{empty}

% Add Authors and Affiliations in the camera ready
% for the double blind review, please leave this section as is 

%\begin{tabular}{cc}
%Yasamin Aali\upstairs{\affilone,*}, Rahnuma Islam Nishat\upstairs{\affilone}, Sheridan Houghten\upstairs{\affilone}\\[0.25ex]
%{\small \upstairs{\affilone} Brock University} \\
%\end{tabular}
  
% Replace with corresponding author email address
%\emails{
%  \upstairs{*}sg24kk@brocku.ca 
%}
\vspace*{0.2in}
\end{center}

\begin{abstract}

Excessive transitions between material zones in 3D printing compromise both efficiency and structural integrity. We introduce a hybrid optimization framework to minimize these zone crossings in Hamiltonian toolpaths. Our approach combines the local search capabilities of Simulated Annealing with the global exploration of a sequence-based Genetic Algorithm. Furthermore, we employ a hybrid neural network (CNN–RNN) that models the learned optimization behavior and predicts efficient sequences of operations. Experiments verify that our method significantly reduces zone crossings across various complex layouts, and proving its effectiveness and scalability for high-quality multi-material additive manufacturing.

\end{abstract}

% add your keywords
\begin{keywords}{Keywords:}
3D Printing, Reconfiguration, Artificial Intelligence
\end{keywords}
\copyrightnotice

\section{Introduction}
{\color{blue}Additive manufacturing (AM) is the process of manufacturing an object by depositing materials (i.e., plastic, metal, wood etc.) layer by layer; 3D printing is one of the most common types of additive manufacturing~\cite{jadhav2022review}. }
%3D printing is the most common type of additive manufacturing (AM) \cite{jadhav2022review}, which uses a digital 3D model to build an object by depositing materials layer-by-layer. 
{\color{blue}As opposed to subtractive manufacturing, 3D printing is popular in many applications such as aerospace \cite{karkun20223d}, biomedical engineering \cite{agarwal2023diverse}, and automotive applications \cite{choudhuri2025review}, because of the ability to manufacture complex geometries with less material waste and rapid customization.} 

Tool paths are the routes that a 3D printer’s head follows to deposit material and create a printed object. These paths play a critical role in determining the quality, speed, and strength of the final product. Therefore, many studies aim to develop better toolpath designs for different objectives, such as improving geometric accuracy or enhancing mechanical performance.

In practical 3D printing, objects may consist of multiple functional \emph{zones}, such as interior regions and outer surfaces, or areas made from different materials {\color{blue}(can we find an example of different materials in the same object? That would be a very good application of our research.)} or colors. Reducing the number of transitions between these zones is therefore critical, as each nozzle crossing increases printing time and repositioning overhead, disrupts material flow, and affects thermal behavior, which in turn reduces print quality. {\color{blue} In other words, minimum \emph{zone crossing} would be desirable, where zone crossing refers to the toolpath crossing the boundary of two zones.  In this paper, we study the problem of optimizing (minimizing) the zone crossing of a toolpath using reconfiguration of Hamiltonian paths and cycles in grid graphs~\cite{}}. 
%To address this, we formulate the problem as minimizing zone crossings, where the nozzle path moves from one predefined zone to another.

Since 3D printing is inherently a layer-by-layer process, we optimize the toolpath independently for each layer and allow the method to scale to complex three-dimensional objects. Each layer is modeled as a two-dimensional grid, where grid cells represent printable units within the layer. We model the nozzle path as a Hamiltonian path over a grid graph, where each vertex represents a printable unit, and the path defines the nozzle's visit to each node. A Hamiltonian path is the best approach for this problem because it visits every node exactly once, ensuring a complete visit without revisiting previously printed parts and {\color{blue}without lifting the nozzle}. This decreases redundant moves and ensures material is deposited efficiently.

We begin with a simple Hamiltonian path that we call a \emph{zigzag} path. {\color{blue}A figure with zigzag paths here. }  %that satisfies the Hamiltonian properties. 
Although the zigzag path is commonly used as an initial toolpath {\color{blue}(where? need reference)}, it is not efficient on its own and typically results in a large number of zone crossings. To safely modify complex structures while preserving their key properties, we use reconfiguration from graph theory. Reconfiguration is the process of transforming one feasible solution of a problem into another through a sequence of small, valid steps, where each intermediate state remains a feasible solution of the original problem. We apply a series of local reconfiguration operations, such as flips and transposes on small subgrids ($3\times2$ or $2\times3$ and $3\times3$, respectively), to iteratively improve the path (figure~\ref{fig:operations}). These operations preserve the Hamiltonian property while enabling the path to change and avoid unnecessary crossings between zones. 

Although applying reconfiguration operations is effective, the large number of available subgrids and multiple flip and transpose patterns create a large combinatorial search space and make it challenging to decide which operations to apply, how often to apply them, and where to apply them efficiently.

Motivated by the significant impact of AI and its success across a wide range of domains, we incorporate AI-driven methods into our optimization framework.

Our primary contributions can be summarized as follows:
\begin{itemize}
    \item We propose a simulated annealing–based optimization framework for minimizing zone crossings in Hamiltonian toolpaths.
    \item We explore a genetic algorithm over operation sequences, leveraging crossover to recombine successful reconfiguration strategies and further improve crossing minimization.
    \item We develop a neural network–guided optimization strategy that learns to predict short sequences of effective reconfiguration operations, aiming to minimize the maximum number of crossings more efficiently.
\end{itemize}

\begin{figure}[t]
    \centering
    \begin{subfigure}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{figs/transpose.png}
        \caption{Transpose}
        \label{fig:zigzag}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{figs/flip.png}
        \caption{Flip}
        \label{fig:optimized}
    \end{subfigure}
    \caption{Reconfiguration operations on Hamiltonian path.}
    \label{fig:operations}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{figs/Pipeline.png}
    \caption{An overview of our hybrid optimization framework}
    \label{fig:pipeline}
\end{figure}

\section{Related Work}
\label{Related Work}

\subsection{3D Printing}
%Heterogeneous objects (HOs) are 3D printed parts made from more than one material, either blended smoothly or placed in separate zones. These multi-material prints are useful for creating parts with different functions, such as stronger corners, flexible joints, or colorful surfaces. However, printing such parts is challenging because switching between materials during printing takes time, wastes material, and can reduce quality. To solve this, researchers focus on the zoning objective, which means dividing the object into well-defined zones and planning the toolpath to reduce the number of material changes. Fewer transitions between zones lead to faster, cleaner, and more efficient printing.

Toolpath strategies are generally divided into contour-parallel and direction-parallel paths. Contour-parallel paths follow the boundary of the shape and are often implemented as spiral patterns. \cite{zhao2016connected} proposed connected Fermat spirals, a simple space-filling toolpath pattern that fills a region using smooth, low-curvature spiral paths that can be joined into one continuous curve. Direction-parallel paths use back-and-forth motions in a fixed direction, commonly known as zigzag patterns. Many studies have compared these two approaches or like \cite{ding2014tool}, which combined zigzag and contour-parallel patterns, to determine more efficient ways to fill a printing area.


\subsection{Applications of AI in 3D Printing}
Many studies have explored the use of AI to improve 3D printing by targeting different objectives through a variety of learning and optimization techniques.

Machine learning (ML) algorithms have been widely applied to tasks such as path planning and parameter optimization. For example, the paper \cite{zhou2021path} used an SVM-based approach to classify polygon sub-domains using geometric features and automatically selected the most suitable fill path, enabling robust and adaptive toolpath planning even with limited training data.

Several works focus on optimizing printing parameters and improving print quality using learning-based models. In \cite{ulkir2023predicting}, a cascade-forward neural network (CFNN) combined with a GA is used to identify optimal input parameters for predicting and minimizing surface roughness. Similarly, \cite{deswal2024optimization} employed a GA assisted by Fuzzy Logic Methodology (FLM) to optimize process parameters and enhance the compressive strength of FDM-fabricated polymer parts. \cite{deswal2019modeling} further demonstrated that hybrid ANN–GA models achieve superior predictive performance compared to conventional artificial neural networks (ANNs) approaches.

Recent studies have highlighted the effectiveness of deep learning models, particularly Convolutional Neural Networks (CNNs), in monitoring and predicting printing outcomes. Among these, \cite{lee2023development} shows that CNNs trained on time-lapse print images outperform other models in identifying print quality defects such as stringing and blobs by tuning hyperparameters including kernel size and activation functions. Likewise, \cite{goh2021review} and \cite{sundaram2023artificial} showed that CNN-based models achieve better performance than traditional approaches in predicting build time, part weight, and mechanical stresses, while simpler three-layer ANNs remain effective for optimizing printing parameters. The growing role of computer vision in AM is further emphasized by \cite{paraskevoudis2020real}, which demonstrates the use of vision-based techniques in Fused Filament Fabrication (FFF) to automatically detect printing errors and improve print quality. In addition, \cite{decker2021geometric} used a random forest model trained on a small set of printed objects to predict geometric deviations in new designs and automatically adjusted CAD models to compensate for these errors.

Beyond parameter tuning and defect detection, optimization-based approaches have been extensively explored. The study \cite{wojcik2015mzz} highlighted that different geometries and printing objectives often require different algorithmic choices, rather than relying on a single universal solution. This has motivated the use of hybrid optimization strategies, such as the GA–PSO combination proposed in \cite{feng2021hybrid}, which effectively reduces material waste by minimizing tree support volume. Similarly, \cite{talaat2021artificial} combined a Support Vector Machine (SVM) with a GA to predict 3D model printability by optimizing factors such as material cost, geometry, and printing time, without relying on fixed heuristic rules. The use of GA for geometric optimization is also shown in \cite{bedel2022closed}, where a GA was applied to optimize space-filling curves for AM by minimizing over-extrusion while maintaining orientation control during printing.

GAs have also been applied to higher-level decision-making and process selection tasks. In \cite{aljabali2024genetic}, a GA was used due to its fitness-based evaluation, providing flexibility in using multiple criteria for AM process selection.


\section{Method}
\label{Method}

\subsection{Simulated Annealing for Crossing Minimization}
Optimizing a Hamiltonian toolpath is a very complex problem with many possible solutions, so we use AI techniques to help guide the search. Among different local-search and evolutionary methods, simulated annealing (SA) works especially well for our goal. Our objective, minimizing the number of zone crossings, requires locally modifying the Hamiltonian path while avoiding early convergence to poor local optima. SA has a good mechanism for exploring the search space while balancing exploitation and exploration through its temperature-controlled acceptance rule. 

At each iteration, SA proposes a new candidate Hamiltonian path by applying a small, local reconfiguration operation to the current path. These operations include transpose moves on \(3 \times 3\) subgrids and flip moves on \(3 \times 2\) or \(2 \times 3\)  subgrids. Instead of choosing subgrids completely at random, the algorithm maintains a move pool which contains only local operations that are valid for the current Hamiltonian path. Because the set of valid operations changes as the path evolves, the pool is refreshed periodically. This reduces wasted attempts and helps the search progress more smoothly. Valid mutations produce a candidate path \(P'\), whose quality is evaluated by the change in crossings,
\[
\Delta = \text{cross}(P') - \text{cross}(P).
\]
If the candidate improves the objective (\(\Delta < 0\)), it is accepted unconditionally. Otherwise, it is accepted with probability
\[
\exp(-\Delta / T),
\]
where \(T\) is the current temperature. This Metropolis acceptance rule allows the algorithm to accept worse moves when \(T\) is high, and helps it escape local minima and has broader exploration in the early stages of the search. If a candidate is rejected, the path is reverted to its previous configuration. If it is accepted, the current cost and the best-so-far solution are updated. To further avoid lack of progress, the algorithm increases the temperature (reheating) when no improvement is observed for several iterations, which allows additional exploration when the search becomes stuck.

Since the algorithm is random and uses temperature to control how it explores different possibilities, it can effectively search through the large and restricted space of Hamiltonian paths. % The steps it takes during this process also generate the data that we later use to train our neural network model.


{\color{blue}Nishat: read upto this level. }

\subsection{Genetic Algorithm}

While SA is effective at improving a single Hamiltonian toolpath using local reconfiguration moves, it operates on only one solution at a time. As a result, SA may fail to explore other configurations that require different sequences of operations. To overcome this limitation, we introduce a GA as a complementary optimization approach. Unlike SA, GA works with a population of solutions and explore multiple candidates simultaneously. By combining and modifying these solutions over generations, GA has broader exploration of the search space and enables useful patterns from different solutions to be reused and recombined.
In our framework, SA is also a high-quality initializer for the GA. Instead of starting from random toolpaths, we first run SA multiple times with different seeds and extract strong solutions from each run. These SA-generated solutions are then used to initialize the GA population, ensuring that the search begins from already good configurations and allowing the GA to focus on refinement and recombination rather than basic improvement.

A first approach was to apply crossover directly to the grid representation of the Hamiltonian path by mixing edges from two parent solutions. However, this strategy quickly becomes problematic because Hamiltonian paths are highly constrained structures. Even small changes can easily break the path, which causes the offspring to violate degree constraints or split into multiple disconnected paths. As a result, most children generated by grid-level crossover are no longer valid Hamiltonian paths. Although we experimented with an Edge Recombination (ER)–style crossover that aims to preserve adjacency relationships from the parent solutions when creating a child. However, in our problem this approach was still not effective. The crossover often produced children that were very similar to their parents, which limited the generation of new and diverse solutions. As a result, the search did not significantly improve exploration, and the cost of producing valid offspring remained high.

This limitation led us to a key insight inspired by \cite{8791445}. They proposed representing a solution as a sequence of local graph-editing operations applied to an initial graph, which makes evolutionary search more efficient and avoids the difficulties of directly evolving graph structures. Instead of recombining Hamiltonian paths directly, we recombine sequences of valid local operations that preserve Hamiltonicity when applied. 

To make this representation precise, each individual in the GA population is defined as a fixed-length sequence of local reconfiguration operations,
\[
\mathcal{S} = (o_1, o_2, \dots, o_L).
\]

Each gene \( o_i \) represents a single local modification applied to the current Hamiltonian path and is defined as a tuple
\[
o_i = (\text{kind}, x, y, \text{variant}).
\]

The field \( \text{kind} \in \{T, F, N\} \) specifies the type of operation.  
Here, \( T \) denotes a \emph{transpose} operation applied to a \(3 \times 3\) subgrid,  
\( F \) denotes a \emph{flip} operation applied to either a \(3 \times 2\) or \(2 \times 3\) subgrid,  
and \( N \) denotes a \emph{no-operation} (NOP), which leaves the path unchanged.
The coordinates \( (x, y) \) indicate the top-left corner of the subgrid on which the operation is applied.  
The parameter \( \text{variant} \) selects a specific valid pattern for the chosen operation type.  
If an SA sequence is shorter than the required genome length 
\emph{L}, it is padded with NOPs; if it is longer, it is truncated.


To choose parent solutions in the ga, we use tournament selection. In this method, a small number of solutions are picked at random from the current population, and the one with the lowest number of zone crossings is selected as a parent. The same process is repeated to select the second parent. This approach helps maintain diversity in the population and prevents premature convergence.

To generate new solutions from existing ones, we apply a one-point crossover operator to the sequences of local reconfiguration operations. Given two parent sequences of length L, a cut position is selected based on a predefined crossover ratio. The child sequence is then constructed by copying the first part of the sequence from the first parent, and the remaining part from the second parent. Crossover is applied with a fixed probability. When crossover is not used, the child is simply copied from one of the parents. This helps preserve good solutions while still allowing new combinations to be explored.

%Mutation is applied to each solution by randomly modifying some of its operations. It selects among three possible actions: a no-operation (noop), a transpose, or a flip. The choice is controlled by predefined probabilities. To further improve effectiveness, mutation is biased toward zone boundaries, where crossings occur. As a result, mutations are more likely to modify parts of the Hamiltonian path that directly influence zone crossings, rather than making uniform random changes across the grid.


\subsection{Neural Network}
After applying local reconfiguration operations and reducing zone crossings with simulated annealing, a question arises: can we learn the underlying patterns in these optimization trajectories and predict effective sequences of operations? 
In other words, rather than relying only on heuristics, we want to train a model that can recognize which operations are useful in different geometric situations and determine an effective sequence for applying them.
To address this, we develop a hybrid neural architecture that combines a convolutional neural network (CNN) with a recurrent neural network (RNN). The CNN extracts spatial features from the grid representation of the Hamiltonian path, while the RNN captures the temporal structure of the optimization process.
It allows the model to learn how sequences of local operations collectively improve the overall path. 

\subsubsection{CNN}
The first part of our model is a CNN that embeds the current Hamiltonian path state into a compact 128-dimensional representation. The CNN takes the grid as an image input with a multi-channel tensor of shape C×H×W, where each channel shows structural features about the path, such as horizontal edges, vertical edges, nodes, or the zone boundary. This lets the network view the toolpath as a geometric shape. The purpose of the CNN is to extract high-level spatial features that characterize the shape, direction patterns, and local irregularities of the path. In our model, the CNN is made up of four layers, each containing a 3×3 convolution, batch normalization, and a ReLU activation. As we go deeper into the network, the number of channels increases, allowing the CNN to learn more complex patterns in the grid. All convolutions use one pixel of padding so that the height and width of the feature maps stay the same. 
After the last convolution layer, the feature map is flattened and passed through a fully connected layer to produce a 128-dimensional vector. This vector is the state embedding, which summarizes the overall shape of the Hamiltonian path at each state like bends in the path, local patterns, and how the path interacts with the zone boundary. We then combine this embedding with a small set of global features, such as the number of crossings and the layer index being optimized, to give the model both local and global information about the state.


\subsubsection{RNN}
While the CNN learns the spatial layout of the current Hamiltonian path, the optimization process happens sequentially, which each operation changes the state in a way that influences future decisions. To capture this temporal dependency, we use a RNN, such as a Gated Recurrent Unit (GRU). At each optimization step the RNN takes in a vector of the 128-dimensional CNN embedding. 
The RNN keeps a hidden state that acts like a memory, storing information about the operations applied so far and how they changed the path. During each forward pass, the RNN processes the current input vector together with the hidden state from the previous step, producing an updated hidden state that summarizes both the current grid configuration and its recent transformation history. 
This design is important because the effect of a mutation operation cannot be evaluated by itself. Some subgrid operations are only beneficial when applied after specific preceding operations. The RNN can capture these relationships by keeping track of the path’s sequential dependencies. 
The recurrent state therefore captures patterns such as: which layers have been explored recently, what kinds of operations were attempted, whether previous flips or transposes improved the zoning objective, and which areas of the grid remain suboptimal. Since the Hamiltonian path changes gradually, the RNN helps the model remember what has already been tried, avoid repeating bad moves, notice useful patterns, and adjust its choices as the optimization progresses.


\section{Experiments}

In our experiments section, we organize our evaluation into three parts:

{\color{red} change this section}

\subsection{Zone Crossing Minimization}

In practical multi-material 3D printing applications, zones are not always simple or evenly shaped. If an algorithm is tested only on a single, simple zone layout, it may perform well in that case but fail in more realistic situations. Using different zone types helps ensure that the algorithm is robust and not tuned to a specific pattern.

To test the algorithm under different conditions and ensure that the algorithm is not designed for only one specific layout but can adapt to different types of zoning, we use several types of zone layouts, ranging from simple to more complex patterns. A simple layout such as left–right zones is used as baseline case because it divides the grid into clear and easy-to-understand regions. Stripe-based zones are included to represent repeated regions across the print, which can occur in layered or multi-material designs. Diagonal zones introduce sloping boundaries and increase the difficulty of the problem by creating non-aligned zone borders. Islands zones create many small regions, making crossing reduction more challenging. Finally, Voronoi-based zones generate irregular and uneven regions that better represent realistic printing scenarios where zones are not uniform in shape or size. 

Figure~\ref{fig:zigzag} shows examples of the different zone layouts with the initial zigzag Hamiltonian path before optimization. Figure~\ref{fig:SA} shows the resulting paths after applying the SA algorithm, highlighting the reduction in zone crossings across different layouts.

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/zigzag.png}
        \caption{Left/Right}
    \end{subfigure}
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/stripes.png}
        \caption{Stipes}
    \end{subfigure}
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/islands.png}
        \caption{Islands}
    \end{subfigure}
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/voronoi.png}
        \caption{Voronoi}
    \end{subfigure}

    \caption{Initial zig-zag path on 4 different zoning patterns}
    \label{fig:zigzag}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/zigzag2.png}
        \caption{Left/Right}
    \end{subfigure}
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/stripes2.png}
        \caption{Stipes}
    \end{subfigure}
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/islands2.png}
        \caption{Islands}
    \end{subfigure}
    \begin{subfigure}{0.35\textwidth}
        \includegraphics[width=\linewidth]{figs/voronoi2.png}
        \caption{Voronoi}
    \end{subfigure}

    \caption{Ompimized paths after applying SA}
    \label{fig:SA}
\end{figure}

%We compare three optimization approaches: SA, GA, and the NN-based method, to evaluate how effectively each method reduces the number of zone crossings in a Hamiltonian toolpath.
We test the algorithms on several zone patterns, such as left–right partitions, striped zones, island-based regions, and Vonoronoi diagrams. By using different zone configurations, we can observe how stable and reliable each algorithm is when the structure of the zones changes. Table 1 compares how these algorithms perform in reducing zone crossings on a $32\times32$ grid.

\begin{table}[h]
\centering
\caption{Comparison between SA and GA models by crossings}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{l|c c c}
\toprule
\multirow{2}{*}{\textbf{Zone Pattern / Model}}\\
& \textbf{SA} & \textbf{GA}\\
\midrule
Left/Right & 14 & -\\
Islands ($k=3$, $8\times8$) & 24 & -\\
Stripes ($k=3$)                & 28 & -\\
Voronoi Diagram ($k=3$)              & 35 & -\\
\bottomrule
\end{tabular}
\end{table}


\subsection{Effect of Grid Size on Performance and Runtime}
We also focus on the effect of grid size on both runtime and optimization quality. As the grid becomes larger, the Hamiltonian path contains more vertices and edges, and the search space grows significantly. This makes the problem more computationally expensive and harder to optimize.

We run SA on grids of increasing sizes and measure the runtime, as well as the number of crossings. This experiment allows us to study the scalability of our method.

\begin{table}[h]
\centering
\caption{Before and after crossings and runtime for different grid sizes}
\renewcommand{\arraystretch}{1.3}
\setlength{\tabcolsep}{8pt}
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|ccc ccc ccc ccc}
\toprule
\multirow{4}{*}{\textbf{Model / Size of Grid}}\\


& \multicolumn{3}{c}{\textbf{30$\times$30}}
& \multicolumn{3}{c}{\textbf{50$\times$50}}
& \multicolumn{3}{c}{\textbf{80$\times$80}}
& \multicolumn{3}{c}{\textbf{100$\times$100}} \\
\cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-10} \cmidrule(lr){11-13}

& \textbf{Before} & \textbf{After} & \textbf{Time}
& \textbf{Before} & \textbf{After} & \textbf{Time}
& \textbf{Before} & \textbf{After} & \textbf{Time}
& \textbf{Before} & \textbf{After} & \textbf{Time} \\
\midrule

Left/Right
& 30 & 20 & 7.8
& 50 & 38 & 67.3
& 80 & 40 & 330.2
& 100 & 46 & 153.7 \\

Islands ($k=3$, $8\times8$)
& 48 & 30 & 10.6
& 48 & 30 & - 
& 48 & 32 & -
& 48 & 26 & - \\

Stripes ($k=3$)
& 60 & 28 & 7.6
& 100 & 54 & - 
& 160 & 92 & -
& 200 & 108 & - \\

Voronoi Diagram ($k=3$)
& 60 & 36 & 7.5
& 99 & 69 & - 
& 142 & 114 & -
& 197 & 151 & - \\

\bottomrule
\end{tabular}}
\end{table}

\begin{table}[h]
\centering
\caption{Before and after crossings and runtime for \(2^{n}\) grid sizes}
\renewcommand{\arraystretch}{1.3}
\setlength{\tabcolsep}{8pt}
\resizebox{\textwidth}{!}{%
\begin{tabular}{l|ccc ccc ccc ccc}
\toprule
\multirow{4}{*}{\textbf{Model / Size of Grid}}\\


& \multicolumn{3}{c}{\textbf{32$\times$32}}
& \multicolumn{3}{c}{\textbf{64$\times$64}}
& \multicolumn{3}{c}{\textbf{32$\times$128}}
& \multicolumn{3}{c}{\textbf{32$\times$256}} \\
\cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-10} \cmidrule(lr){11-13}

& \textbf{Before} & \textbf{After} & \textbf{Time}
& \textbf{Before} & \textbf{After} & \textbf{Time}
& \textbf{Before} & \textbf{After} & \textbf{Time}
& \textbf{Before} & \textbf{After} & \textbf{Time} \\
\midrule

Left/Right
& 32 & 12 & 7.4
& 64 & 30 & 101.1
& 128 & 62 & 2081.4
& 32 & - & - \\

Islands ($k=3$, $8\times8$)
& 48 & 32 & 7.9
& 48 & 30 & 104.2
& - & - & -
& - & - & - \\

Stripes ($k=3$)
& 64 & 30 & 6.9
& 128 & 66 & 102.8
& - & - & -
& - & - & - \\

Voronoi Diagram ($k=3$)
& 64 & 38 & 6.8
& 128 & 70 & 98.2
& - & - & -
& - & - & - \\

\bottomrule
\end{tabular}}
\end{table}




\subsection{Dataset and Metric}

\subsubsection{Dataset Construction}
To evaluate our method, we generate a dataset by running the SA algorithm under different settings. We repeat SA several times using different random seeds so that the dataset contains a variety of optimization paths, rather than results from a single run.
For each SA run, we store the grid size, zone pattern, random seed, initial and final number of crossings, runtime, and the sequence of applied local operations (transpose and flip). This dataset is used both to analyze the performance of simulated annealing and to provide strong initial solutions for the GA.

In addition to the solutions produced by SA, we also extend the dataset using solutions generated by the GA. During GA optimization, each individual represents a sequence of local produces a valid child solution, its resulting path and operation sequence are evaluated using the same crossing metric.

\subsubsection{Evaluation Metrics}

We evaluate solution quality primarily using the number of zone crossings, which directly reflects the objective of minimizing unnecessary toolpath transitions between zones. A lower crossing count indicates a more efficient and cleaner toolpath.

In addition to final crossing count, we also report the initial number of crossings and the improvement achieved by the algorithm. To assess computational efficiency, we record the runtime of each optimization run.

For the genetic algorithm, we further track the best crossing value achieved per generation and the diversity of the population, measured by the number of distinct fitness values. These metrics help analyze convergence behavior and the effectiveness of evolutionary operators.

\subsection{Implementation details}

\section{Comparison and Results}

In this section, we evaluate the performance of our three proposed strategies, SA, GA, and the NN guided approach, against the baseline zigzag toolpath. We analyze these methods based on solution quality (minimization of crossings), sequence efficiency (operation count), and computational scalability.

\subsection{Minimization of Zone Crossings}

All two optimization methods(SA and GA) significantly outperformed the standard zigzag toolpath. The baseline zigzag path resulted in a high number of crossings equal to the zone transitions (e.g., 30 crossings for a $30 \times 30$ Left/Right pattern).

As the primary optimization engine, SA demonstrated strong performance and significantly reduced crossings across all zone patterns. In the $30 \times 30$ Left/Right scenario, SA reduced the crossings from 30 to 20, representing a \(33.3\%\) reduction. For the more complex "Voronoi" pattern, SA reduced crossings from 60 down to 36, a reduction of \(40.0\%\).

The GA acted as a refinement layer and pushed the optimization further to find global minima. Initialized with SA solutions, the GA successfully reduced the crossings in the Left/Right pattern from the SA baseline of 20 down to -. This represents a total reduction of \(-\%\) from the original zigzag path.

\subsection{Sequence Efficiency and Neural Prediction}



\section{Conclusion}

This paper presents a hybrid AI framework to minimize zone crossings in multi-material 3D printing toolpaths. By applying local reconfiguration operations, our SA framework successfully reduced zone crossings by approximately 45–56\%\ across various patterns. We further enhanced this using a GA that evolves sequences of operations. ...

While these search-based methods yield high-quality solutions, we further minimized the number of operations required to achieve minimum crossings. To address this, we introduced a hybrid Neural Network (CNN-RNN) that learns spatial and temporal patterns to rapidly predict effective reconfiguration sequences without exhaustive search.
...


Currently, our approach optimizes each layer independently as a 2D plane on a square grid. However, real-world additive manufacturing involves complex geometries and requires vertical consistency. In our future work, We plan to have experiments on diverse polygon shapes to validate the algorithm's robustness across complex, non-rectangular geometries.
we will also implement a layer-aware optimization strategy for full 3D objects. Instead of generating new paths from scratch for every layer, the algorithm will make small, incremental adjustments to the optimized path of the previous layer.

\section*{Acknowledgements}
This section can be left blank during double-blind review. 


%Appendixes go here
\appendix

\section{Example of math equation }


% All references should be stored in the file "references.bib".
% That call to use that file is in "cai.cls". 
% Please do not modify anything below this line.
\printbibliography[heading=subbibintoc]

\end{document}
